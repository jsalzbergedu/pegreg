%% -*- TeX-command-extra-options: "-shell-escape" ; eval: (LaTeX-math-mode)  ; eval: (TeX-engine-set 'luatex)-*-
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\author {Jacob Salzberg}
\date{\today}
\title{Potential Fixedpoint Semantics for PEGREG}

\usepackage{float} % For putting figures directly after text
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[ligature, inference]{semantic}
\usepackage{galois}
\newcommand{\emptytrace}{\ni}
\newcommand{\traceconcat}{\mathbin{\textcolor[HTML]{0a3d62}{\tiny{\fermata}}}}
\newcommand{\environments}{\textcolor[HTML]{b71540}{\mathbbm{Ev}}}
\newcommand{\pgmset}{{\mathbbm{P}}}
\newcommand{\pgmcmp}{\mathbbm{Pc}}
\newcommand{\pgm}{\mbox{P}}
\newcommand{\stmt}{\textcolor[HTML]{0a3d62}{\textsf{\mbox{S}}}}
\newcommand{\semantic}{{\mathcal{S}}}
\newcommand{\stmtlist}{\mathbin{\textcolor[HTML]{0a3d62}{\textsf{\mbox{Sl}}}}}
\newcommand{\emptysl}{\mathbin{\textcolor[HTML]{0a3d62}{\epsilon}}}
\newcommand{\stmtlistset}{\mathit{\mathbbm{Sl}}}
\newcommand{\stmtset}{\mathit{\textcolor[HTML]{0a3d62}{\mathbbm{S}}}}
\newcommand{\aexpr}{\textcolor[HTML]{b71540}{\mbox{\texttt{A}}}}
\newcommand{\aeval}{\mathcal{A}}
\newcommand{\beval}{\mathcal{B}}
\newcommand{\traces}{\mathscr{T}}
\newcommand{\Fp}{\mathscr{F}}
\newcommand{\bexpr}{\textcolor[HTML]{b71540}{\mbox{\texttt{B}}}}
\newcommand{\true}{\textcolor[HTML]{000000}{\textsf{\mbox{tt}}}}
\newcommand{\false}{\textcolor[HTML]{000000}{\textsf{\mbox{ff}}}}
\newcommand{\lbl}{{\textcolor[HTML]{3c6382}{ℓ}}}
\newcommand{\synif}[1]{{\kern-0.20em}\mathbin{\mbox{\texttt{\textbf{\textcolor[HTML]{0a3d62}{if}}}}}#1\mathbin{}}
\newcommand{\synassign}{\mathbin{\mbox{\texttt{\textbf{\textcolor[HTML]{0a3d62}{=}}}}}}
\newcommand{\synskip}{\mathbin{\mbox{\texttt{\textbf{\textcolor[HTML]{0a3d62}{;}}}}}}
\newcommand{\synelse}{\mathbin{\mbox{\texttt{\textbf{ \textcolor[HTML]{0a3d62}{else} }}}}}
\newcommand{\synwhile}[1]{{\kern-0.20em}\mathbin{\mbox{\texttt{\textbf{\textcolor[HTML]{0a3d62}{while}}}}}#1\mathbin{}}
\newcommand{\synbreak}{\mbox{\texttt{\textbf{\textcolor[HTML]{0a3d62}{break;}}}}}
\newcommand{\synvar}{{\mbox{{\texttt{\textbf{\textcolor[HTML]{b71540}{x}}}}}}}
\newcommand{\variables}{\textcolor[HTML]{b71540}{\mathbbmsl{V}}}
\newcommand{\tracevalues}{\textcolor[HTML]{000000}{\mathbbm{V}}}
\newcommand{\tracevalue}{\mbox{\textit{v}}}
\newcommand{\traceaction}{\mbox{{\tt a}}}
\newcommand{\traceactions}{\textcolor[HTML]{3c6382}{\mathbbmsl{A}}}
\newcommand{\trace}{\mathbbm{T}}
\newcommand{\tracearrow}[1]{{\textcolor[HTML]{3c6382}{\xrightarrow{\textcolor[HTML]{000000}{#1}}}}{}}
\newcommand{\nand}{\mbox{ nand }}
\newcommand{\pcat}{\textcolor[HTML]{3c6382}{\textsf{\mbox{at}}}}
\newcommand{\pcafter}{\textcolor[HTML]{3c6382}{\textsf{\mbox{after}}}}
\newcommand{\pcescape}{\textcolor[HTML]{3c6382}{\textsf{\mbox{escape}}}}
\newcommand{\pcbreakto}{\textcolor[HTML]{3c6382}{\textsf{\mbox{break-to}}}}
\newcommand{\pcbreaksof}{\textcolor[HTML]{3c6382}{\textsf{\mbox{breaks-of}}}}
\newcommand{\pcin}{\textcolor[HTML]{3c6382}{\textsf{\mbox{in}}}}
\newcommand{\pclabs}{\textcolor[HTML]{3c6382}{\textsf{\mbox{labs}}}}
\newcommand{\pclabx}{\textcolor[HTML]{3c6382}{\textsf{\mbox{labx}}}}
\newcommand{\definiendum}{D}
\newcommand{\universe}{\mathbbm{U}}
\newcommand{\increasing}{\xrightarrow{\nearrow}}
\newcommand{\tojoin}{\xrightarrow{\sqcup}}
\newcommand{\tomeet}{\xrightarrow{\sqcap}}
\renewcommand{\lambda}{\textcolor[HTML]{8e44ad}{\lambda}}
\newcommand{\abs}{\mathscr{A}}
\newcommand{\crc}{\mathscr{C}}
\newcommand{\preproperty}{ℙ}
\newcommand{\postproperty}{ℚ}
\newcommand{\post}{\mbox{post}}
\newcommand{\dpost}{\widetilde{\mbox{post}}}
\newcommand{\lfp}{{\kern-0.20em}\mathbin{\mbox{lfp}}}
\newcommand{\synPeg}{\ensuremath{\operatorname{\tt peg}}}
\newcommand{\synReg}{\ensuremath{\operatorname{\tt reg}}}
\newcommand{\synRegEmp}{\ensuremath{\operatorname{\tt \varepsilon}}}
\newcommand{\setPeg}{\mathit{Peg}}
\newcommand{\setReg}{\mathit{Reg}}
\newcommand{\funPEGREG}{\operatorname{\mathit{pegreg}}}
\newcommand{\funPegMatch}{\operatorname{\mathit{pegMatch}}}
\newcommand{\funRegMatch}{\operatorname{\mathit{regMatch}}}
\newcommand{\funNegate}{\operatorname{\mathit{negate}}}
\DeclareMathSymbol{\mhyphen}{\mathord}{AMSa}{"39}
%% End book symbols

%%% \begin{envBNF}{pagewidth}{caption}{label} math text \end{envBNF}
%%% formats math text to display
%%% meta : set ::= alt0
%%%             |  alt1 ...
%%%             |  altn
%%% via tabular environment
\NewDocumentEnvironment{envBNF}{m m m}%
               {%
                 \begin{figure}[H]%
                   \centering%
                   \begin{minipage}{#1}%
                     \begin{tabular}{lclclcl}}%
               {%
                     \end{tabular}%
                   \end{minipage}%
                   \caption{#2}%
                   \label{#3}%
                 \end{figure}}

% ==============================================================================
% BNF commands
% ~~~~~~~~~~~~
%%% \bnfRule{meta}{set}{alt0} formats rules of the form
%%% meta : set ::= alt0
%%% where meta, set, and alt0 are math text.
\newcommand{\bnfRule}[3]{$#1$ & $\in$ & $#2$ & $::=$ & $#3$ \\}
%%% \bnfAlt{altn} formats rules of the form
%%%            |   altn
%%% where altn is math text.
\newcommand{\bnfAlt}[1]{& & & | & $#1$ \\}
% ==============================================================================

\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}

\usepackage{tikz}
\usepackage{fancyvrb}
\usepackage[T1]{fontenc}
\begin{document}

\begin{definition} Strings \\
  For a set $X$, we define strings over $X$ to be elements of
  the free monoid over $X$, called $X^*$.

  \noindent We use the notation
  $\cdot : (\mathit{String} \times \mathit{String}) \to \mathit{String}$
  to mean the concatenation of strings.
\end{definition}

\begin{definition} Alphabet \\
  Let $\Sigma$ be an arbitrary, finite set.
  This document will call $\Sigma$ the Alphabet.
  We will let $c$ be a metavariable ranging over $\Sigma$,
  and s be a metavariable ranging over $\Sigma^*$, ie, strings of $\Sigma$.
\end{definition}

\begin{definition} Parsing Expression Grammars \\
  We define the set $\setPeg$ via the following bnf formula, overloading the operator
  $\cdot$

\begin{envBNF}{0.40\textwidth}{Parsing Expression Grammar Syntax}{fig:PEGSyntax}
  \bnfRule{\synPeg}{\setPeg}{c \in \Sigma}
  \bnfAlt{\synPeg_1 \cdot \synPeg_2}
  \bnfAlt{\synPeg_1 / \synPeg_2}
  \bnfAlt{\synPeg^*}
\end{envBNF}

These rules are called character, sequence, choice, and possesive star
respectively.
\end{definition}

\begin{definition} Regular Expressions \\
  We define the set $\setReg$ via the following bnf formula, again overloading the
  operator $\cdot$

\begin{envBNF}{0.40\textwidth}{Regular Expression Grammar Syntax}{fig:REGSyntax}
  \bnfRule{\synReg}{\setReg}{\synRegEmp}
  \bnfAlt{c \in \Sigma}
  \bnfAlt{.}
  \bnfAlt{\bot}
  \bnfAlt{\synReg_1 \cdot \synReg_2}
  \bnfAlt{\synReg_1 \cup \synReg_2}
  \bnfAlt{\synReg_1 \cap \synReg_2}
  \bnfAlt{\neg\synReg}
  \bnfAlt{\synReg^*}
\end{envBNF}

These rules are empty, character, any, empty, sequence, union, intersection,
negation, and kleene star respectively.
\end{definition}

\begin{definition} Parsing Expression Grammar Matching \\
  Letting $\mathit{Matched} = \Sigma^*$ and $\mathit{Remainder} = \Sigma^*$,

  \noindent We inherit the partial function
  $\funPegMatch : (\setPeg \times \Sigma^*) \nrightarrow (\mathit{Matched} \times \mathit{Remainder}) \uplus \{\bot\}$

  \noindent from the paper
  ``Towards a Typed Semantics for Parsing Expression Grammars''.
\end{definition}

\begin{definition} Character Of \\
  For a set $X$ with elements $x \in X$, we say that
  $x$ is a character of the string $\mathit{xs} \in X^*$ iff

  \noindent
  $\exists (\mathit{prf}, \mathit{suf} \in X^*),
     \mathit{xs} = \mathit{prf} \cdot x \cdot \mathit{suf}$

  \noindent We use the notation $x \mathop{char{\mhyphen}of} \mathit{xs}$
  to mean $x$ is a character of the string $xs$.
\end{definition}

\begin{definition} Regular Expression Matching \\
  We define $\funRegMatch : (\synReg \times \Sigma^*) \to \mathbb{B}$ recursively:
  $ \\
  \funRegMatch(\varepsilon, \varepsilon) = \mathit{\tt t} \\
  \funRegMatch(\varepsilon, c \cdot s) = \mathit{\tt f} \\
  \funRegMatch(c, c) = \mathit{\tt t} \\
  \funRegMatch(c, \varepsilon) = \mathit{\tt f} \\
  \funRegMatch(c, c') \mbox{ where } c \not= c' = \mathit{\tt f} \\
  \funRegMatch(c, c' \cdot s) = \mathit{\tt f} \\
  \funRegMatch(\cdot, c) = \mathit{\tt t} \\
  \funRegMatch(\cdot, c' \cdot s) = \mathit{\tt f} \\
  \funRegMatch(\bot, s) = \mathit{\tt f} \\
  \funRegMatch(\synReg_1 \cdot \synReg_2, s) = \exists (s', s'' \in \Sigma^*), s = s' \cdot s'' \land
      \funRegMatch(\synReg_1, s') \land \funRegMatch(\synReg_2, s'') \\
  \funRegMatch(\synReg_1 \cup \synReg_2, s) = \funRegMatch(\synReg_1, s) \lor \funRegMatch(\synReg_2, s) \\
  \funRegMatch(\synReg_1 \cap \synReg_2, s) = \funRegMatch(\synReg_1, s) \land \funRegMatch(\synReg_2, s) \\
  \funRegMatch(\neg\synReg_1, s) = \neg\funRegMatch(\synReg_1, s)\\
  \funRegMatch(\synReg_1^*, s) = \exists (ss \in \Sigma^{**}), \bigwedge_{s \mathop{char{\mhyphen}of} ss}
    \funRegMatch(\synReg_1, s)\\
  $

  While most rules are self explanatory, the rule for concatenation and star
  may not be.

  Concatenation splits the string into two halves, the first of
  which matches to the left regex, and the second to the right.

  Star considers all possible splits of the string, and requires that the
  constituent strings of the split are each matched by the subexpression.

\end{definition}

%%% Maybe we can still do the mutual recursion?

%%% pegreg(c, reg) = c.reg
%%% pegreg(p1.p2, reg) = pegreg(p1, pegreg(p2, reg))
%%% pegreg(p1/p2, reg) = pegregi(p1, reg) union
%%%                     (pegreg(p2, reg) intersection negate(p1))
%%% pegreg(p*, reg) = pegreg(p, emp)*.(reg intersection negate(p))
%%%
%%% negate(c) = . intersection (!c)
%%% negate(p1.p2) = negate(p1) union pegreg(p1, negate(p2))
%%% negate(p1/p2) = negate(p1) intersection (negate(p2))
%%% negate(p1*) = {}

\begin{definition} Parsing Expression Grammar Translation \\

  On input $(\synPeg, \synReg)$, the function $\funPEGREG$ produces a regular expression
  with the characters consumed by $\synPeg$ removed. It is defined in mutual
  recursion with the $\funNegate$ function, which on input $\synPeg$, generates a regular
  expression corresponding to the set of characters that cause $\synPeg$ to match
  $\bot$.

\begin{alignat}{2}& \notag
 \funPEGREG : (\setPeg \times \setReg) \to \setReg \\&
 \funPEGREG(c, \synReg)  =  c \cdot \synReg \\&
 \funPEGREG(\synPeg_1 \cdot \synPeg_2, \synReg)  =  \funPEGREG(\synPeg_1, \funPEGREG(\synPeg_2, \synReg)) \\&
 \funPEGREG(\synPeg_1/\synPeg_2, \synReg)  =  \funPEGREG(\synPeg_1, \synReg) \cup
  (\funPEGREG(\synPeg_2, \synReg) \cap \funNegate(\synPeg_1) \operatorname{\cdot}.^*)\\&
 \funPEGREG(\synPeg^*, \synReg)  =  \funPEGREG(\synPeg, \varepsilon)^* \cdot
  (\synReg \cap \funNegate(\synPeg) \operatorname{\cdot} .^*) \\&\notag \\&\notag
\funNegate : \setPeg \to \setReg \\&
\funNegate(c) = . \cap {\neg}c\\&
\funNegate(\synPeg_1 \cdot \synPeg_2) = \funNegate(\synPeg_1) \cup \funPEGREG(\synPeg_1, \funNegate(\synPeg_2)) \\&
\funNegate(\synPeg_1 / \synPeg_2) = \funNegate(\synPeg_1) \cap \funNegate(\synPeg_2) \\&
\funNegate(\synPeg^*) = \bot
\end{alignat}
\end{definition}

\begin{proposition}
  Characterization of correspondance needs rework!
\end{proposition}

\end{document}
